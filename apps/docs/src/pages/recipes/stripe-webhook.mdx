# Setting up a Stripe webhook with Kaito

An advantage of Kaito moving to support Request/Response APIs in v3 is that it made it super easy to setup a Stripe webhook. You can read more at the bottom of this page about why that was the case.

## Example

```ts filename="context.ts"
import {create} from '@kaito-http/core';

export const router = create({
	getContext: async (req, head) => {
		return {
			bodyAsText: async () => await req.text(),
		};
	},
});
```

```ts filename="stripe.ts"
import {router} from './context.ts';
import {KaitoError} from '@kaito-http/core';
import stripe from '@stripe/stripe-js';

// Create a crypto provider for stripe to use, required in some runtimes that don't define `crypto.subtle` globally.
// If you're unsure, try without, and then bring it back if you get an error.
const webCrypto = stripe.createSubtleCryptoProvider();

// Notice how we don't define a body schema, we're using stripe's webhook logic to parse the body for us
// which requires the raw body as a string.
export const stripe = router.post('/webhook', async ({ctx}) => {
	const body = await ctx.bodyAsText();

	const sig = ctx.req.headers.get('stripe-signature');

	if (!sig) {
		throw new KaitoError(400, 'No signature provided');
	}

	const event = await stripe.webhooks.constructEventAsync(
		body,
		sig,
		process.env.STRIPE_ENDPOINT_SECRET!, // You should validate this exists, and not use the `!` operator
		undefined,
		webCrypto,
	);

	// Handle different event types
	switch (event.type) {
		case 'payment_intent.succeeded':
			// Handle successful payment
			break;
		// Add other event types as needed
	}
});
```

<Callout>
	For production webhooks, always implement proper error handling and logging. Stripe will retry failed webhook
	deliveries, so make sure your endpoint is idempotent and can handle duplicate events.
</Callout>

## What did v3 change?

Accessing the request body before Kaito v3 was pretty difficult and required a good understanding of the `node:http` module. Since Stripe's
APIs expect a raw text body, very delicate code was needed to read the request at the right time, and then pass it to the Stripe library.

The `Request` API in Kaito v3 makes this a lot easier. By not passing a body schema to the route, we can access the raw text body lazily,
and then pass it to the Stripe library.
